# 1주차

GoN qual에 나왔던 리버싱 문제 일부 업솔빙



## Run

##### 풀이

main이 플래그를 인코딩하는 데 사용된 바이너리다. 

비트 단위로 입력을 받고 1을 만나기까지 연속한 0의 개수에 따라 인코딩을 한다. 

연속한 0의 개수를 C라고 했을 때, '1' * (C를 나타내는데 필요한 비트수) + '0' + (C를 비트로 표현) 가 출력된다. 

0을 기준으로 정보가 분리되므로 flag.enc 파일에서 find(0)을 반복하면서 디코딩해주면 플래그가 적힌 png 파일이 나온다. 



##### 헤맨 부분

wb 모드로 flag.png 파일 출력을 하기 위해서 int를 byte로 바꿔야 한다. 

이 부분에서 `chr(x).encode()` 같이 int -> string -> byte로 변환했었는데, `chr(128).encode() == b'\xc2\x80'` 같은 경우가 발생해서 의도한대로 코드가 동작하지 않았다. 

`int.to_bytes(length, byteorder)` 를 사용해서 int를 바로 byte로 바꿔주니 제대로 된 파일이 나왔다. 



## pyc

##### 풀이

prob.pyc 를 디스어셈블해서 분석한다. 

`throw` 함수가 `chk.__code__` 에 m을 xor한다. `chk.__code__`에 m을 xor한 후 chk를 분석한다. 

chk를 역연산해서 플래그를 구한다. 



##### 헤맨 부분

online pyc decompiler에서 prob.pyc가 디컴파일이 안되길래 pyc에 대해 찾아봤다. 

pyc 파일의 초기 4바이트에는 매직 넘버가 존재한다. 버전에 따라서 파이썬 코드를 바이트 코드(pyc 파일)로 바꾸는 세부 방식이 다르고, 버전마다 다른 매직 넘버를 가지고 있다. 파이썬 버전에 따른 매직 넘버를 모아놓은 페이지를 찾아서 prob.pyc에 있는 매직 넘버를 검색해봤는데 해당하는 파이썬 버전이 없었다. 그래서 나는 난독화가 사용된 것으로 판단했고, 매직 넘버를 브루트포스해야 되나? 까지 생각하고 풀이를 물어봤다. 

prob.pyc에 있는 매직 넘버는 파이썬 3.10 버전에 해당하는 것이었고, 내가 찾았던 페이지에는 최신 버전이 반영이 안 돼있던 거였다. 3.10 버전 디컴파일러는 아직 완전한 게 없다는 듯 해서, [pycdas](https://github.com/zrax/pycdc)를 사용해서 prob.pyc를 디스어셈블하고 직접 해석했다. 



