# 1주차

dreamhack에서 리버싱에 대한 이론을 간략히 공부했다.

총 12강이며 모든 강의를 수강했으나 이번 주는 3강의 이론에 대한 요약만 보고한다. 다음주까지 9강의 내용도 요약하여 정리한다. 리눅스 기반 환경에서 컴파일한 바이너리의 실행 흐름을 파악하기 위한 기초 세팅을 만들 준비를 했다.


# stage1 intro

    software reverse engineering : 

    각종 프로그램을 분석해서 기능과 설계를 파악.

    cf) 키제네레이터 프로그램, 시리얼 넘버 생성기, 크랙 등


# stage2 binary & analysis

    * binary

    이해 : 

    바이너리의 정의를 알고, 컴파일 과정을 이해

    전처리에 대한 이해

    컴파일과 최적화 과정

    어셈블과 object 파일(리눅스의 ELF/ 윈도우의 PE)

    링크에 대한 이해

    디스어셈블, 디컴파일의 목적과 결과

    프로그램: 컴퓨터가 실행해야 할 명령어의 집합, 바이너리라고도 불림

    __________________________________

    용어 정리 : 

    전처리: 소스 코드가 컴파일에 필요한 형식으로 가공되는 과정

    컴파일: 소스 코드를 어셈블리어로 번역하는 과정

    어셈블: 어셈블리 코드를 기계어로 번역하고, 실행 가능한 형식의 변형하는 과정

    링크: 여러 개의 목적 파일을 하나로 묶고, 필요한 라이브러리와 연결해주는 과정

    디스어셈블: 바이너리를 어셈블리어로 번역하는 과정

    디컴파일: 바이너리를 고급 언어로 번역하는 과정

    * analysis

    이해 : 

     소프트웨어를 분석시 
     
     1) 큰 구조를 먼저 관찰합니다. 이것만으로 소프트웨어의 실제 동작을 알기 어려울 때가 많다. 
     
     2) 프로그램을 실행해보며 동작을 관찰.
     
     3) 기타 수단을 동원하여 특정 부분을 세밀하게 관찰.

        정적 분석(Static Analysis) / 동적 분석(Dynamic Analysis)
    
        동적인 방법만을 고수하면 큰 구조를 놓칠 수 있고, 반대로 정적인 방법만을 고수하면 실행을 통해 직관적으로 알 수 있는 부분을 분석하느라 시간을 허비할 수 있으므로 상황에 따라 적절한 방법을 선택. 
    
    용어 정리 : 

    정적 분석 : 외적인 관찰만을 통해 정보를 알아내는 것
    
    동적 분석 : 실행을 통해 동작을 분석하는 것


    



